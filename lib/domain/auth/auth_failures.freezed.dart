// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'auth_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

// ignore: unused_element
  FCanceledByUser<T> canceledByUser<T>() {
    return FCanceledByUser<T>();
  }

// ignore: unused_element
  FServerError<T> serverError<T>() {
    return FServerError<T>();
  }

// ignore: unused_element
  FNotAllowed<T> notAllowed<T>() {
    return FNotAllowed<T>();
  }

// ignore: unused_element
  _FAccountExistWithDifferentCredential<T>
      accountExistWithDifferentCredential<T>() {
    return _FAccountExistWithDifferentCredential<T>();
  }

// ignore: unused_element
  _InvalidCredential<T> invalidCredential<T>() {
    return _InvalidCredential<T>();
  }

// ignore: unused_element
  FInvalidEmailPasswordCombination<T> invalidEmailPasswordCombination<T>() {
    return FInvalidEmailPasswordCombination<T>();
  }

// ignore: unused_element
  FUserNotFound<T> userNotFound<T>() {
    return FUserNotFound<T>();
  }

// ignore: unused_element
  FInvalidEmail<T> invalidEmail<T>() {
    return FInvalidEmail<T>();
  }

// ignore: unused_element
  FInvalidEmailOrPasswordValue<T> invalidEmailOrPasswordValue<T>() {
    return FInvalidEmailOrPasswordValue<T>();
  }

// ignore: unused_element
  FemailAlreadyExist<T> emailAlreadyExist<T>() {
    return FemailAlreadyExist<T>();
  }
}

/// @nodoc
// ignore: unused_element
const $AuthFailure = _$AuthFailureTearOff();

/// @nodoc
mixin _$AuthFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $AuthFailureCopyWith<T, $Res> {
  factory $AuthFailureCopyWith(
          AuthFailure<T> value, $Res Function(AuthFailure<T>) then) =
      _$AuthFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<T, $Res>
    implements $AuthFailureCopyWith<T, $Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure<T> _value;
  // ignore: unused_field
  final $Res Function(AuthFailure<T>) _then;
}

/// @nodoc
abstract class $FCanceledByUserCopyWith<T, $Res> {
  factory $FCanceledByUserCopyWith(
          FCanceledByUser<T> value, $Res Function(FCanceledByUser<T>) then) =
      _$FCanceledByUserCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FCanceledByUserCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FCanceledByUserCopyWith<T, $Res> {
  _$FCanceledByUserCopyWithImpl(
      FCanceledByUser<T> _value, $Res Function(FCanceledByUser<T>) _then)
      : super(_value, (v) => _then(v as FCanceledByUser<T>));

  @override
  FCanceledByUser<T> get _value => super._value as FCanceledByUser<T>;
}

/// @nodoc
class _$FCanceledByUser<T> implements FCanceledByUser<T> {
  const _$FCanceledByUser();

  @override
  String toString() {
    return 'AuthFailure<$T>.canceledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FCanceledByUser<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return canceledByUser();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (canceledByUser != null) {
      return canceledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return canceledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (canceledByUser != null) {
      return canceledByUser(this);
    }
    return orElse();
  }
}

abstract class FCanceledByUser<T> implements AuthFailure<T> {
  const factory FCanceledByUser() = _$FCanceledByUser<T>;
}

/// @nodoc
abstract class $FServerErrorCopyWith<T, $Res> {
  factory $FServerErrorCopyWith(
          FServerError<T> value, $Res Function(FServerError<T>) then) =
      _$FServerErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FServerErrorCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FServerErrorCopyWith<T, $Res> {
  _$FServerErrorCopyWithImpl(
      FServerError<T> _value, $Res Function(FServerError<T>) _then)
      : super(_value, (v) => _then(v as FServerError<T>));

  @override
  FServerError<T> get _value => super._value as FServerError<T>;
}

/// @nodoc
class _$FServerError<T> implements FServerError<T> {
  const _$FServerError();

  @override
  String toString() {
    return 'AuthFailure<$T>.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FServerError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class FServerError<T> implements AuthFailure<T> {
  const factory FServerError() = _$FServerError<T>;
}

/// @nodoc
abstract class $FNotAllowedCopyWith<T, $Res> {
  factory $FNotAllowedCopyWith(
          FNotAllowed<T> value, $Res Function(FNotAllowed<T>) then) =
      _$FNotAllowedCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FNotAllowedCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FNotAllowedCopyWith<T, $Res> {
  _$FNotAllowedCopyWithImpl(
      FNotAllowed<T> _value, $Res Function(FNotAllowed<T>) _then)
      : super(_value, (v) => _then(v as FNotAllowed<T>));

  @override
  FNotAllowed<T> get _value => super._value as FNotAllowed<T>;
}

/// @nodoc
class _$FNotAllowed<T> implements FNotAllowed<T> {
  const _$FNotAllowed();

  @override
  String toString() {
    return 'AuthFailure<$T>.notAllowed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FNotAllowed<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return notAllowed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAllowed != null) {
      return notAllowed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return notAllowed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAllowed != null) {
      return notAllowed(this);
    }
    return orElse();
  }
}

abstract class FNotAllowed<T> implements AuthFailure<T> {
  const factory FNotAllowed() = _$FNotAllowed<T>;
}

/// @nodoc
abstract class _$FAccountExistWithDifferentCredentialCopyWith<T, $Res> {
  factory _$FAccountExistWithDifferentCredentialCopyWith(
          _FAccountExistWithDifferentCredential<T> value,
          $Res Function(_FAccountExistWithDifferentCredential<T>) then) =
      __$FAccountExistWithDifferentCredentialCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$FAccountExistWithDifferentCredentialCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements _$FAccountExistWithDifferentCredentialCopyWith<T, $Res> {
  __$FAccountExistWithDifferentCredentialCopyWithImpl(
      _FAccountExistWithDifferentCredential<T> _value,
      $Res Function(_FAccountExistWithDifferentCredential<T>) _then)
      : super(_value,
            (v) => _then(v as _FAccountExistWithDifferentCredential<T>));

  @override
  _FAccountExistWithDifferentCredential<T> get _value =>
      super._value as _FAccountExistWithDifferentCredential<T>;
}

/// @nodoc
class _$_FAccountExistWithDifferentCredential<T>
    implements _FAccountExistWithDifferentCredential<T> {
  const _$_FAccountExistWithDifferentCredential();

  @override
  String toString() {
    return 'AuthFailure<$T>.accountExistWithDifferentCredential()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _FAccountExistWithDifferentCredential<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return accountExistWithDifferentCredential();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (accountExistWithDifferentCredential != null) {
      return accountExistWithDifferentCredential();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return accountExistWithDifferentCredential(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (accountExistWithDifferentCredential != null) {
      return accountExistWithDifferentCredential(this);
    }
    return orElse();
  }
}

abstract class _FAccountExistWithDifferentCredential<T>
    implements AuthFailure<T> {
  const factory _FAccountExistWithDifferentCredential() =
      _$_FAccountExistWithDifferentCredential<T>;
}

/// @nodoc
abstract class _$InvalidCredentialCopyWith<T, $Res> {
  factory _$InvalidCredentialCopyWith(_InvalidCredential<T> value,
          $Res Function(_InvalidCredential<T>) then) =
      __$InvalidCredentialCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$InvalidCredentialCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements _$InvalidCredentialCopyWith<T, $Res> {
  __$InvalidCredentialCopyWithImpl(
      _InvalidCredential<T> _value, $Res Function(_InvalidCredential<T>) _then)
      : super(_value, (v) => _then(v as _InvalidCredential<T>));

  @override
  _InvalidCredential<T> get _value => super._value as _InvalidCredential<T>;
}

/// @nodoc
class _$_InvalidCredential<T> implements _InvalidCredential<T> {
  const _$_InvalidCredential();

  @override
  String toString() {
    return 'AuthFailure<$T>.invalidCredential()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InvalidCredential<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidCredential();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidCredential != null) {
      return invalidCredential();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidCredential(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidCredential != null) {
      return invalidCredential(this);
    }
    return orElse();
  }
}

abstract class _InvalidCredential<T> implements AuthFailure<T> {
  const factory _InvalidCredential() = _$_InvalidCredential<T>;
}

/// @nodoc
abstract class $FInvalidEmailPasswordCombinationCopyWith<T, $Res> {
  factory $FInvalidEmailPasswordCombinationCopyWith(
          FInvalidEmailPasswordCombination<T> value,
          $Res Function(FInvalidEmailPasswordCombination<T>) then) =
      _$FInvalidEmailPasswordCombinationCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FInvalidEmailPasswordCombinationCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FInvalidEmailPasswordCombinationCopyWith<T, $Res> {
  _$FInvalidEmailPasswordCombinationCopyWithImpl(
      FInvalidEmailPasswordCombination<T> _value,
      $Res Function(FInvalidEmailPasswordCombination<T>) _then)
      : super(_value, (v) => _then(v as FInvalidEmailPasswordCombination<T>));

  @override
  FInvalidEmailPasswordCombination<T> get _value =>
      super._value as FInvalidEmailPasswordCombination<T>;
}

/// @nodoc
class _$FInvalidEmailPasswordCombination<T>
    implements FInvalidEmailPasswordCombination<T> {
  const _$FInvalidEmailPasswordCombination();

  @override
  String toString() {
    return 'AuthFailure<$T>.invalidEmailPasswordCombination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FInvalidEmailPasswordCombination<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmailPasswordCombination();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailPasswordCombination != null) {
      return invalidEmailPasswordCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmailPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailPasswordCombination != null) {
      return invalidEmailPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class FInvalidEmailPasswordCombination<T> implements AuthFailure<T> {
  const factory FInvalidEmailPasswordCombination() =
      _$FInvalidEmailPasswordCombination<T>;
}

/// @nodoc
abstract class $FUserNotFoundCopyWith<T, $Res> {
  factory $FUserNotFoundCopyWith(
          FUserNotFound<T> value, $Res Function(FUserNotFound<T>) then) =
      _$FUserNotFoundCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FUserNotFoundCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FUserNotFoundCopyWith<T, $Res> {
  _$FUserNotFoundCopyWithImpl(
      FUserNotFound<T> _value, $Res Function(FUserNotFound<T>) _then)
      : super(_value, (v) => _then(v as FUserNotFound<T>));

  @override
  FUserNotFound<T> get _value => super._value as FUserNotFound<T>;
}

/// @nodoc
class _$FUserNotFound<T> implements FUserNotFound<T> {
  const _$FUserNotFound();

  @override
  String toString() {
    return 'AuthFailure<$T>.userNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FUserNotFound<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return userNotFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (userNotFound != null) {
      return userNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return userNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (userNotFound != null) {
      return userNotFound(this);
    }
    return orElse();
  }
}

abstract class FUserNotFound<T> implements AuthFailure<T> {
  const factory FUserNotFound() = _$FUserNotFound<T>;
}

/// @nodoc
abstract class $FInvalidEmailCopyWith<T, $Res> {
  factory $FInvalidEmailCopyWith(
          FInvalidEmail<T> value, $Res Function(FInvalidEmail<T>) then) =
      _$FInvalidEmailCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FInvalidEmailCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FInvalidEmailCopyWith<T, $Res> {
  _$FInvalidEmailCopyWithImpl(
      FInvalidEmail<T> _value, $Res Function(FInvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as FInvalidEmail<T>));

  @override
  FInvalidEmail<T> get _value => super._value as FInvalidEmail<T>;
}

/// @nodoc
class _$FInvalidEmail<T> implements FInvalidEmail<T> {
  const _$FInvalidEmail();

  @override
  String toString() {
    return 'AuthFailure<$T>.invalidEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FInvalidEmail<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmail();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class FInvalidEmail<T> implements AuthFailure<T> {
  const factory FInvalidEmail() = _$FInvalidEmail<T>;
}

/// @nodoc
abstract class $FInvalidEmailOrPasswordValueCopyWith<T, $Res> {
  factory $FInvalidEmailOrPasswordValueCopyWith(
          FInvalidEmailOrPasswordValue<T> value,
          $Res Function(FInvalidEmailOrPasswordValue<T>) then) =
      _$FInvalidEmailOrPasswordValueCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FInvalidEmailOrPasswordValueCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FInvalidEmailOrPasswordValueCopyWith<T, $Res> {
  _$FInvalidEmailOrPasswordValueCopyWithImpl(
      FInvalidEmailOrPasswordValue<T> _value,
      $Res Function(FInvalidEmailOrPasswordValue<T>) _then)
      : super(_value, (v) => _then(v as FInvalidEmailOrPasswordValue<T>));

  @override
  FInvalidEmailOrPasswordValue<T> get _value =>
      super._value as FInvalidEmailOrPasswordValue<T>;
}

/// @nodoc
class _$FInvalidEmailOrPasswordValue<T>
    implements FInvalidEmailOrPasswordValue<T> {
  const _$FInvalidEmailOrPasswordValue();

  @override
  String toString() {
    return 'AuthFailure<$T>.invalidEmailOrPasswordValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FInvalidEmailOrPasswordValue<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmailOrPasswordValue();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailOrPasswordValue != null) {
      return invalidEmailOrPasswordValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return invalidEmailOrPasswordValue(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailOrPasswordValue != null) {
      return invalidEmailOrPasswordValue(this);
    }
    return orElse();
  }
}

abstract class FInvalidEmailOrPasswordValue<T> implements AuthFailure<T> {
  const factory FInvalidEmailOrPasswordValue() =
      _$FInvalidEmailOrPasswordValue<T>;
}

/// @nodoc
abstract class $FemailAlreadyExistCopyWith<T, $Res> {
  factory $FemailAlreadyExistCopyWith(FemailAlreadyExist<T> value,
          $Res Function(FemailAlreadyExist<T>) then) =
      _$FemailAlreadyExistCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FemailAlreadyExistCopyWithImpl<T, $Res>
    extends _$AuthFailureCopyWithImpl<T, $Res>
    implements $FemailAlreadyExistCopyWith<T, $Res> {
  _$FemailAlreadyExistCopyWithImpl(
      FemailAlreadyExist<T> _value, $Res Function(FemailAlreadyExist<T>) _then)
      : super(_value, (v) => _then(v as FemailAlreadyExist<T>));

  @override
  FemailAlreadyExist<T> get _value => super._value as FemailAlreadyExist<T>;
}

/// @nodoc
class _$FemailAlreadyExist<T> implements FemailAlreadyExist<T> {
  const _$FemailAlreadyExist();

  @override
  String toString() {
    return 'AuthFailure<$T>.emailAlreadyExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FemailAlreadyExist<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult canceledByUser(),
    @required TResult serverError(),
    @required TResult notAllowed(),
    @required TResult accountExistWithDifferentCredential(),
    @required TResult invalidCredential(),
    @required TResult invalidEmailPasswordCombination(),
    @required TResult userNotFound(),
    @required TResult invalidEmail(),
    @required TResult invalidEmailOrPasswordValue(),
    @required TResult emailAlreadyExist(),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return emailAlreadyExist();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult canceledByUser(),
    TResult serverError(),
    TResult notAllowed(),
    TResult accountExistWithDifferentCredential(),
    TResult invalidCredential(),
    TResult invalidEmailPasswordCombination(),
    TResult userNotFound(),
    TResult invalidEmail(),
    TResult invalidEmailOrPasswordValue(),
    TResult emailAlreadyExist(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyExist != null) {
      return emailAlreadyExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult canceledByUser(FCanceledByUser<T> value),
    @required TResult serverError(FServerError<T> value),
    @required TResult notAllowed(FNotAllowed<T> value),
    @required
        TResult accountExistWithDifferentCredential(
            _FAccountExistWithDifferentCredential<T> value),
    @required TResult invalidCredential(_InvalidCredential<T> value),
    @required
        TResult invalidEmailPasswordCombination(
            FInvalidEmailPasswordCombination<T> value),
    @required TResult userNotFound(FUserNotFound<T> value),
    @required TResult invalidEmail(FInvalidEmail<T> value),
    @required
        TResult invalidEmailOrPasswordValue(
            FInvalidEmailOrPasswordValue<T> value),
    @required TResult emailAlreadyExist(FemailAlreadyExist<T> value),
  }) {
    assert(canceledByUser != null);
    assert(serverError != null);
    assert(notAllowed != null);
    assert(accountExistWithDifferentCredential != null);
    assert(invalidCredential != null);
    assert(invalidEmailPasswordCombination != null);
    assert(userNotFound != null);
    assert(invalidEmail != null);
    assert(invalidEmailOrPasswordValue != null);
    assert(emailAlreadyExist != null);
    return emailAlreadyExist(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult canceledByUser(FCanceledByUser<T> value),
    TResult serverError(FServerError<T> value),
    TResult notAllowed(FNotAllowed<T> value),
    TResult accountExistWithDifferentCredential(
        _FAccountExistWithDifferentCredential<T> value),
    TResult invalidCredential(_InvalidCredential<T> value),
    TResult invalidEmailPasswordCombination(
        FInvalidEmailPasswordCombination<T> value),
    TResult userNotFound(FUserNotFound<T> value),
    TResult invalidEmail(FInvalidEmail<T> value),
    TResult invalidEmailOrPasswordValue(FInvalidEmailOrPasswordValue<T> value),
    TResult emailAlreadyExist(FemailAlreadyExist<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyExist != null) {
      return emailAlreadyExist(this);
    }
    return orElse();
  }
}

abstract class FemailAlreadyExist<T> implements AuthFailure<T> {
  const factory FemailAlreadyExist() = _$FemailAlreadyExist<T>;
}
