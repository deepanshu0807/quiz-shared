// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

// ignore: unused_element
  VFInvalidEmail<T> invalidEmailAdress<T>({@required T failedValue}) {
    return VFInvalidEmail<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFShortPassword<T> shortPassword<T>({@required T failedValue}) {
    return VFShortPassword<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInvalidName<T> invalidName<T>({@required T failedValue}) {
    return VFInvalidName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInvalidID<T> invalidID<T>({@required T failedValue}) {
    return VFInvalidID<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInvalidPhone<T> invalidPhone<T>({@required T failedValue}) {
    return VFInvalidPhone<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInvalidOTP<T> invalidOTP<T>({@required T failedValue}) {
    return VFInvalidOTP<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInproperListLength<T> inproperListLength<T>({@required T failedValue}) {
    return VFInproperListLength<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInvalidDescription<T> invalidDescription<T>({@required T failedValue}) {
    return VFInvalidDescription<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInValidPrice<T> inValidPrice<T>({@required T failedValue}) {
    return VFInValidPrice<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInValidPercentage<T> inValidPercentage<T>({@required T failedValue}) {
    return VFInValidPercentage<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  VFInValidQuantity<T> inValidQuantity<T>({@required T failedValue}) {
    return VFInValidQuantity<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  });

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
abstract class $VFInvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidEmailCopyWith(
          VFInvalidEmail<T> value, $Res Function(VFInvalidEmail<T>) then) =
      _$VFInvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidEmailCopyWith<T, $Res> {
  _$VFInvalidEmailCopyWithImpl(
      VFInvalidEmail<T> _value, $Res Function(VFInvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidEmail<T>));

  @override
  VFInvalidEmail<T> get _value => super._value as VFInvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidEmail<T>
    with DiagnosticableTreeMixin
    implements VFInvalidEmail<T> {
  const _$VFInvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidEmailAdress(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidEmailAdress'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidEmailCopyWith<T, VFInvalidEmail<T>> get copyWith =>
      _$VFInvalidEmailCopyWithImpl<T, VFInvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidEmailAdress(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAdress != null) {
      return invalidEmailAdress(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidEmailAdress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAdress != null) {
      return invalidEmailAdress(this);
    }
    return orElse();
  }
}

abstract class VFInvalidEmail<T> implements ValueFailure<T> {
  const factory VFInvalidEmail({@required T failedValue}) = _$VFInvalidEmail<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidEmailCopyWith<T, VFInvalidEmail<T>> get copyWith;
}

/// @nodoc
abstract class $VFShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFShortPasswordCopyWith(
          VFShortPassword<T> value, $Res Function(VFShortPassword<T>) then) =
      _$VFShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFShortPasswordCopyWith<T, $Res> {
  _$VFShortPasswordCopyWithImpl(
      VFShortPassword<T> _value, $Res Function(VFShortPassword<T>) _then)
      : super(_value, (v) => _then(v as VFShortPassword<T>));

  @override
  VFShortPassword<T> get _value => super._value as VFShortPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFShortPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFShortPassword<T>
    with DiagnosticableTreeMixin
    implements VFShortPassword<T> {
  const _$VFShortPassword({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.shortPassword'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFShortPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFShortPasswordCopyWith<T, VFShortPassword<T>> get copyWith =>
      _$VFShortPasswordCopyWithImpl<T, VFShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class VFShortPassword<T> implements ValueFailure<T> {
  const factory VFShortPassword({@required T failedValue}) =
      _$VFShortPassword<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFShortPasswordCopyWith<T, VFShortPassword<T>> get copyWith;
}

/// @nodoc
abstract class $VFInvalidNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidNameCopyWith(
          VFInvalidName<T> value, $Res Function(VFInvalidName<T>) then) =
      _$VFInvalidNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidNameCopyWith<T, $Res> {
  _$VFInvalidNameCopyWithImpl(
      VFInvalidName<T> _value, $Res Function(VFInvalidName<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidName<T>));

  @override
  VFInvalidName<T> get _value => super._value as VFInvalidName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidName<T>
    with DiagnosticableTreeMixin
    implements VFInvalidName<T> {
  const _$VFInvalidName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidName'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidNameCopyWith<T, VFInvalidName<T>> get copyWith =>
      _$VFInvalidNameCopyWithImpl<T, VFInvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class VFInvalidName<T> implements ValueFailure<T> {
  const factory VFInvalidName({@required T failedValue}) = _$VFInvalidName<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidNameCopyWith<T, VFInvalidName<T>> get copyWith;
}

/// @nodoc
abstract class $VFInvalidIDCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidIDCopyWith(
          VFInvalidID<T> value, $Res Function(VFInvalidID<T>) then) =
      _$VFInvalidIDCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidIDCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidIDCopyWith<T, $Res> {
  _$VFInvalidIDCopyWithImpl(
      VFInvalidID<T> _value, $Res Function(VFInvalidID<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidID<T>));

  @override
  VFInvalidID<T> get _value => super._value as VFInvalidID<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidID<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidID<T> with DiagnosticableTreeMixin implements VFInvalidID<T> {
  const _$VFInvalidID({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidID(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidID'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidID<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidIDCopyWith<T, VFInvalidID<T>> get copyWith =>
      _$VFInvalidIDCopyWithImpl<T, VFInvalidID<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidID(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidID != null) {
      return invalidID(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidID(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidID != null) {
      return invalidID(this);
    }
    return orElse();
  }
}

abstract class VFInvalidID<T> implements ValueFailure<T> {
  const factory VFInvalidID({@required T failedValue}) = _$VFInvalidID<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidIDCopyWith<T, VFInvalidID<T>> get copyWith;
}

/// @nodoc
abstract class $VFInvalidPhoneCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidPhoneCopyWith(
          VFInvalidPhone<T> value, $Res Function(VFInvalidPhone<T>) then) =
      _$VFInvalidPhoneCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidPhoneCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidPhoneCopyWith<T, $Res> {
  _$VFInvalidPhoneCopyWithImpl(
      VFInvalidPhone<T> _value, $Res Function(VFInvalidPhone<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidPhone<T>));

  @override
  VFInvalidPhone<T> get _value => super._value as VFInvalidPhone<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidPhone<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidPhone<T>
    with DiagnosticableTreeMixin
    implements VFInvalidPhone<T> {
  const _$VFInvalidPhone({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidPhone(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidPhone'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidPhone<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidPhoneCopyWith<T, VFInvalidPhone<T>> get copyWith =>
      _$VFInvalidPhoneCopyWithImpl<T, VFInvalidPhone<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidPhone(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhone != null) {
      return invalidPhone(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhone != null) {
      return invalidPhone(this);
    }
    return orElse();
  }
}

abstract class VFInvalidPhone<T> implements ValueFailure<T> {
  const factory VFInvalidPhone({@required T failedValue}) = _$VFInvalidPhone<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidPhoneCopyWith<T, VFInvalidPhone<T>> get copyWith;
}

/// @nodoc
abstract class $VFInvalidOTPCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidOTPCopyWith(
          VFInvalidOTP<T> value, $Res Function(VFInvalidOTP<T>) then) =
      _$VFInvalidOTPCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidOTPCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidOTPCopyWith<T, $Res> {
  _$VFInvalidOTPCopyWithImpl(
      VFInvalidOTP<T> _value, $Res Function(VFInvalidOTP<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidOTP<T>));

  @override
  VFInvalidOTP<T> get _value => super._value as VFInvalidOTP<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidOTP<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidOTP<T>
    with DiagnosticableTreeMixin
    implements VFInvalidOTP<T> {
  const _$VFInvalidOTP({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidOTP(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidOTP'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidOTP<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidOTPCopyWith<T, VFInvalidOTP<T>> get copyWith =>
      _$VFInvalidOTPCopyWithImpl<T, VFInvalidOTP<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidOTP(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidOTP != null) {
      return invalidOTP(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidOTP != null) {
      return invalidOTP(this);
    }
    return orElse();
  }
}

abstract class VFInvalidOTP<T> implements ValueFailure<T> {
  const factory VFInvalidOTP({@required T failedValue}) = _$VFInvalidOTP<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidOTPCopyWith<T, VFInvalidOTP<T>> get copyWith;
}

/// @nodoc
abstract class $VFInproperListLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInproperListLengthCopyWith(VFInproperListLength<T> value,
          $Res Function(VFInproperListLength<T>) then) =
      _$VFInproperListLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInproperListLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInproperListLengthCopyWith<T, $Res> {
  _$VFInproperListLengthCopyWithImpl(VFInproperListLength<T> _value,
      $Res Function(VFInproperListLength<T>) _then)
      : super(_value, (v) => _then(v as VFInproperListLength<T>));

  @override
  VFInproperListLength<T> get _value => super._value as VFInproperListLength<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInproperListLength<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInproperListLength<T>
    with DiagnosticableTreeMixin
    implements VFInproperListLength<T> {
  const _$VFInproperListLength({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inproperListLength(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inproperListLength'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInproperListLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInproperListLengthCopyWith<T, VFInproperListLength<T>> get copyWith =>
      _$VFInproperListLengthCopyWithImpl<T, VFInproperListLength<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inproperListLength(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inproperListLength != null) {
      return inproperListLength(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inproperListLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inproperListLength != null) {
      return inproperListLength(this);
    }
    return orElse();
  }
}

abstract class VFInproperListLength<T> implements ValueFailure<T> {
  const factory VFInproperListLength({@required T failedValue}) =
      _$VFInproperListLength<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInproperListLengthCopyWith<T, VFInproperListLength<T>> get copyWith;
}

/// @nodoc
abstract class $VFInvalidDescriptionCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidDescriptionCopyWith(VFInvalidDescription<T> value,
          $Res Function(VFInvalidDescription<T>) then) =
      _$VFInvalidDescriptionCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidDescriptionCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidDescriptionCopyWith<T, $Res> {
  _$VFInvalidDescriptionCopyWithImpl(VFInvalidDescription<T> _value,
      $Res Function(VFInvalidDescription<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidDescription<T>));

  @override
  VFInvalidDescription<T> get _value => super._value as VFInvalidDescription<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInvalidDescription<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInvalidDescription<T>
    with DiagnosticableTreeMixin
    implements VFInvalidDescription<T> {
  const _$VFInvalidDescription({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidDescription(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidDescription'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidDescription<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidDescriptionCopyWith<T, VFInvalidDescription<T>> get copyWith =>
      _$VFInvalidDescriptionCopyWithImpl<T, VFInvalidDescription<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidDescription(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDescription != null) {
      return invalidDescription(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return invalidDescription(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDescription != null) {
      return invalidDescription(this);
    }
    return orElse();
  }
}

abstract class VFInvalidDescription<T> implements ValueFailure<T> {
  const factory VFInvalidDescription({@required T failedValue}) =
      _$VFInvalidDescription<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInvalidDescriptionCopyWith<T, VFInvalidDescription<T>> get copyWith;
}

/// @nodoc
abstract class $VFInValidPriceCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidPriceCopyWith(
          VFInValidPrice<T> value, $Res Function(VFInValidPrice<T>) then) =
      _$VFInValidPriceCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidPriceCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidPriceCopyWith<T, $Res> {
  _$VFInValidPriceCopyWithImpl(
      VFInValidPrice<T> _value, $Res Function(VFInValidPrice<T>) _then)
      : super(_value, (v) => _then(v as VFInValidPrice<T>));

  @override
  VFInValidPrice<T> get _value => super._value as VFInValidPrice<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInValidPrice<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInValidPrice<T>
    with DiagnosticableTreeMixin
    implements VFInValidPrice<T> {
  const _$VFInValidPrice({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidPrice(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidPrice'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidPrice<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidPriceCopyWith<T, VFInValidPrice<T>> get copyWith =>
      _$VFInValidPriceCopyWithImpl<T, VFInValidPrice<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidPrice(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidPrice != null) {
      return inValidPrice(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidPrice != null) {
      return inValidPrice(this);
    }
    return orElse();
  }
}

abstract class VFInValidPrice<T> implements ValueFailure<T> {
  const factory VFInValidPrice({@required T failedValue}) = _$VFInValidPrice<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInValidPriceCopyWith<T, VFInValidPrice<T>> get copyWith;
}

/// @nodoc
abstract class $VFInValidPercentageCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidPercentageCopyWith(VFInValidPercentage<T> value,
          $Res Function(VFInValidPercentage<T>) then) =
      _$VFInValidPercentageCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidPercentageCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidPercentageCopyWith<T, $Res> {
  _$VFInValidPercentageCopyWithImpl(VFInValidPercentage<T> _value,
      $Res Function(VFInValidPercentage<T>) _then)
      : super(_value, (v) => _then(v as VFInValidPercentage<T>));

  @override
  VFInValidPercentage<T> get _value => super._value as VFInValidPercentage<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInValidPercentage<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInValidPercentage<T>
    with DiagnosticableTreeMixin
    implements VFInValidPercentage<T> {
  const _$VFInValidPercentage({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidPercentage(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidPercentage'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidPercentage<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidPercentageCopyWith<T, VFInValidPercentage<T>> get copyWith =>
      _$VFInValidPercentageCopyWithImpl<T, VFInValidPercentage<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidPercentage(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidPercentage != null) {
      return inValidPercentage(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidPercentage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidPercentage != null) {
      return inValidPercentage(this);
    }
    return orElse();
  }
}

abstract class VFInValidPercentage<T> implements ValueFailure<T> {
  const factory VFInValidPercentage({@required T failedValue}) =
      _$VFInValidPercentage<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInValidPercentageCopyWith<T, VFInValidPercentage<T>> get copyWith;
}

/// @nodoc
abstract class $VFInValidQuantityCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidQuantityCopyWith(VFInValidQuantity<T> value,
          $Res Function(VFInValidQuantity<T>) then) =
      _$VFInValidQuantityCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidQuantityCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidQuantityCopyWith<T, $Res> {
  _$VFInValidQuantityCopyWithImpl(
      VFInValidQuantity<T> _value, $Res Function(VFInValidQuantity<T>) _then)
      : super(_value, (v) => _then(v as VFInValidQuantity<T>));

  @override
  VFInValidQuantity<T> get _value => super._value as VFInValidQuantity<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(VFInValidQuantity<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$VFInValidQuantity<T>
    with DiagnosticableTreeMixin
    implements VFInValidQuantity<T> {
  const _$VFInValidQuantity({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidQuantity(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidQuantity'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidQuantity<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidQuantityCopyWith<T, VFInValidQuantity<T>> get copyWith =>
      _$VFInValidQuantityCopyWithImpl<T, VFInValidQuantity<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidEmailAdress(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult invalidName(T failedValue),
    @required TResult invalidID(T failedValue),
    @required TResult invalidPhone(T failedValue),
    @required TResult invalidOTP(T failedValue),
    @required TResult inproperListLength(T failedValue),
    @required TResult invalidDescription(T failedValue),
    @required TResult inValidPrice(T failedValue),
    @required TResult inValidPercentage(T failedValue),
    @required TResult inValidQuantity(T failedValue),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidQuantity(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidEmailAdress(T failedValue),
    TResult shortPassword(T failedValue),
    TResult invalidName(T failedValue),
    TResult invalidID(T failedValue),
    TResult invalidPhone(T failedValue),
    TResult invalidOTP(T failedValue),
    TResult inproperListLength(T failedValue),
    TResult invalidDescription(T failedValue),
    TResult inValidPrice(T failedValue),
    TResult inValidPercentage(T failedValue),
    TResult inValidQuantity(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidQuantity != null) {
      return inValidQuantity(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidEmailAdress(VFInvalidEmail<T> value),
    @required TResult shortPassword(VFShortPassword<T> value),
    @required TResult invalidName(VFInvalidName<T> value),
    @required TResult invalidID(VFInvalidID<T> value),
    @required TResult invalidPhone(VFInvalidPhone<T> value),
    @required TResult invalidOTP(VFInvalidOTP<T> value),
    @required TResult inproperListLength(VFInproperListLength<T> value),
    @required TResult invalidDescription(VFInvalidDescription<T> value),
    @required TResult inValidPrice(VFInValidPrice<T> value),
    @required TResult inValidPercentage(VFInValidPercentage<T> value),
    @required TResult inValidQuantity(VFInValidQuantity<T> value),
  }) {
    assert(invalidEmailAdress != null);
    assert(shortPassword != null);
    assert(invalidName != null);
    assert(invalidID != null);
    assert(invalidPhone != null);
    assert(invalidOTP != null);
    assert(inproperListLength != null);
    assert(invalidDescription != null);
    assert(inValidPrice != null);
    assert(inValidPercentage != null);
    assert(inValidQuantity != null);
    return inValidQuantity(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidEmailAdress(VFInvalidEmail<T> value),
    TResult shortPassword(VFShortPassword<T> value),
    TResult invalidName(VFInvalidName<T> value),
    TResult invalidID(VFInvalidID<T> value),
    TResult invalidPhone(VFInvalidPhone<T> value),
    TResult invalidOTP(VFInvalidOTP<T> value),
    TResult inproperListLength(VFInproperListLength<T> value),
    TResult invalidDescription(VFInvalidDescription<T> value),
    TResult inValidPrice(VFInValidPrice<T> value),
    TResult inValidPercentage(VFInValidPercentage<T> value),
    TResult inValidQuantity(VFInValidQuantity<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (inValidQuantity != null) {
      return inValidQuantity(this);
    }
    return orElse();
  }
}

abstract class VFInValidQuantity<T> implements ValueFailure<T> {
  const factory VFInValidQuantity({@required T failedValue}) =
      _$VFInValidQuantity<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $VFInValidQuantityCopyWith<T, VFInValidQuantity<T>> get copyWith;
}
