// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'infra_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$InfraFailureTearOff {
  const _$InfraFailureTearOff();

// ignore: unused_element
  SFUnexpected<T> unexpected<T>() {
    return SFUnexpected<T>();
  }

// ignore: unused_element
  SFInsufficientPermissions<T> insufficientPermissions<T>() {
    return SFInsufficientPermissions<T>();
  }

// ignore: unused_element
  SFServerError<T> serverError<T>() {
    return SFServerError<T>();
  }

// ignore: unused_element
  SFInValidData<T> invalidData<T>() {
    return SFInValidData<T>();
  }

// ignore: unused_element
  SFInvalidPin<T> invalidPin<T>() {
    return SFInvalidPin<T>();
  }

// ignore: unused_element
  SFCustomerNotFound<T> notFound<T>() {
    return SFCustomerNotFound<T>();
  }

// ignore: unused_element
  SFCouldNotFindStore<T> couldNotFindStore<T>() {
    return SFCouldNotFindStore<T>();
  }

// ignore: unused_element
  SFImageUploadError<T> imageUploadError<T>() {
    return SFImageUploadError<T>();
  }

// ignore: unused_element
  SFUnIdentifiedLocation<T> unIdentifiedLocation<T>() {
    return SFUnIdentifiedLocation<T>();
  }

// ignore: unused_element
  SFPaymentFailure<T> paymentFailure<T>() {
    return SFPaymentFailure<T>();
  }
}

/// @nodoc
// ignore: unused_element
const $InfraFailure = _$InfraFailureTearOff();

/// @nodoc
mixin _$InfraFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $InfraFailureCopyWith<T, $Res> {
  factory $InfraFailureCopyWith(
          InfraFailure<T> value, $Res Function(InfraFailure<T>) then) =
      _$InfraFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$InfraFailureCopyWithImpl<T, $Res>
    implements $InfraFailureCopyWith<T, $Res> {
  _$InfraFailureCopyWithImpl(this._value, this._then);

  final InfraFailure<T> _value;
  // ignore: unused_field
  final $Res Function(InfraFailure<T>) _then;
}

/// @nodoc
abstract class $SFUnexpectedCopyWith<T, $Res> {
  factory $SFUnexpectedCopyWith(
          SFUnexpected<T> value, $Res Function(SFUnexpected<T>) then) =
      _$SFUnexpectedCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFUnexpectedCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFUnexpectedCopyWith<T, $Res> {
  _$SFUnexpectedCopyWithImpl(
      SFUnexpected<T> _value, $Res Function(SFUnexpected<T>) _then)
      : super(_value, (v) => _then(v as SFUnexpected<T>));

  @override
  SFUnexpected<T> get _value => super._value as SFUnexpected<T>;
}

/// @nodoc
class _$SFUnexpected<T> implements SFUnexpected<T> {
  const _$SFUnexpected();

  @override
  String toString() {
    return 'InfraFailure<$T>.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFUnexpected<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class SFUnexpected<T> implements InfraFailure<T> {
  const factory SFUnexpected() = _$SFUnexpected<T>;
}

/// @nodoc
abstract class $SFInsufficientPermissionsCopyWith<T, $Res> {
  factory $SFInsufficientPermissionsCopyWith(SFInsufficientPermissions<T> value,
          $Res Function(SFInsufficientPermissions<T>) then) =
      _$SFInsufficientPermissionsCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFInsufficientPermissionsCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFInsufficientPermissionsCopyWith<T, $Res> {
  _$SFInsufficientPermissionsCopyWithImpl(SFInsufficientPermissions<T> _value,
      $Res Function(SFInsufficientPermissions<T>) _then)
      : super(_value, (v) => _then(v as SFInsufficientPermissions<T>));

  @override
  SFInsufficientPermissions<T> get _value =>
      super._value as SFInsufficientPermissions<T>;
}

/// @nodoc
class _$SFInsufficientPermissions<T> implements SFInsufficientPermissions<T> {
  const _$SFInsufficientPermissions();

  @override
  String toString() {
    return 'InfraFailure<$T>.insufficientPermissions()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFInsufficientPermissions<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return insufficientPermissions();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (insufficientPermissions != null) {
      return insufficientPermissions();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return insufficientPermissions(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (insufficientPermissions != null) {
      return insufficientPermissions(this);
    }
    return orElse();
  }
}

abstract class SFInsufficientPermissions<T> implements InfraFailure<T> {
  const factory SFInsufficientPermissions() = _$SFInsufficientPermissions<T>;
}

/// @nodoc
abstract class $SFServerErrorCopyWith<T, $Res> {
  factory $SFServerErrorCopyWith(
          SFServerError<T> value, $Res Function(SFServerError<T>) then) =
      _$SFServerErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFServerErrorCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFServerErrorCopyWith<T, $Res> {
  _$SFServerErrorCopyWithImpl(
      SFServerError<T> _value, $Res Function(SFServerError<T>) _then)
      : super(_value, (v) => _then(v as SFServerError<T>));

  @override
  SFServerError<T> get _value => super._value as SFServerError<T>;
}

/// @nodoc
class _$SFServerError<T> implements SFServerError<T> {
  const _$SFServerError();

  @override
  String toString() {
    return 'InfraFailure<$T>.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFServerError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class SFServerError<T> implements InfraFailure<T> {
  const factory SFServerError() = _$SFServerError<T>;
}

/// @nodoc
abstract class $SFInValidDataCopyWith<T, $Res> {
  factory $SFInValidDataCopyWith(
          SFInValidData<T> value, $Res Function(SFInValidData<T>) then) =
      _$SFInValidDataCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFInValidDataCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFInValidDataCopyWith<T, $Res> {
  _$SFInValidDataCopyWithImpl(
      SFInValidData<T> _value, $Res Function(SFInValidData<T>) _then)
      : super(_value, (v) => _then(v as SFInValidData<T>));

  @override
  SFInValidData<T> get _value => super._value as SFInValidData<T>;
}

/// @nodoc
class _$SFInValidData<T> implements SFInValidData<T> {
  const _$SFInValidData();

  @override
  String toString() {
    return 'InfraFailure<$T>.invalidData()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFInValidData<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return invalidData();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidData != null) {
      return invalidData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return invalidData(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidData != null) {
      return invalidData(this);
    }
    return orElse();
  }
}

abstract class SFInValidData<T> implements InfraFailure<T> {
  const factory SFInValidData() = _$SFInValidData<T>;
}

/// @nodoc
abstract class $SFInvalidPinCopyWith<T, $Res> {
  factory $SFInvalidPinCopyWith(
          SFInvalidPin<T> value, $Res Function(SFInvalidPin<T>) then) =
      _$SFInvalidPinCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFInvalidPinCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFInvalidPinCopyWith<T, $Res> {
  _$SFInvalidPinCopyWithImpl(
      SFInvalidPin<T> _value, $Res Function(SFInvalidPin<T>) _then)
      : super(_value, (v) => _then(v as SFInvalidPin<T>));

  @override
  SFInvalidPin<T> get _value => super._value as SFInvalidPin<T>;
}

/// @nodoc
class _$SFInvalidPin<T> implements SFInvalidPin<T> {
  const _$SFInvalidPin();

  @override
  String toString() {
    return 'InfraFailure<$T>.invalidPin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFInvalidPin<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return invalidPin();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPin != null) {
      return invalidPin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return invalidPin(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPin != null) {
      return invalidPin(this);
    }
    return orElse();
  }
}

abstract class SFInvalidPin<T> implements InfraFailure<T> {
  const factory SFInvalidPin() = _$SFInvalidPin<T>;
}

/// @nodoc
abstract class $SFCustomerNotFoundCopyWith<T, $Res> {
  factory $SFCustomerNotFoundCopyWith(SFCustomerNotFound<T> value,
          $Res Function(SFCustomerNotFound<T>) then) =
      _$SFCustomerNotFoundCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFCustomerNotFoundCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFCustomerNotFoundCopyWith<T, $Res> {
  _$SFCustomerNotFoundCopyWithImpl(
      SFCustomerNotFound<T> _value, $Res Function(SFCustomerNotFound<T>) _then)
      : super(_value, (v) => _then(v as SFCustomerNotFound<T>));

  @override
  SFCustomerNotFound<T> get _value => super._value as SFCustomerNotFound<T>;
}

/// @nodoc
class _$SFCustomerNotFound<T> implements SFCustomerNotFound<T> {
  const _$SFCustomerNotFound();

  @override
  String toString() {
    return 'InfraFailure<$T>.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFCustomerNotFound<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class SFCustomerNotFound<T> implements InfraFailure<T> {
  const factory SFCustomerNotFound() = _$SFCustomerNotFound<T>;
}

/// @nodoc
abstract class $SFCouldNotFindStoreCopyWith<T, $Res> {
  factory $SFCouldNotFindStoreCopyWith(SFCouldNotFindStore<T> value,
          $Res Function(SFCouldNotFindStore<T>) then) =
      _$SFCouldNotFindStoreCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFCouldNotFindStoreCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFCouldNotFindStoreCopyWith<T, $Res> {
  _$SFCouldNotFindStoreCopyWithImpl(SFCouldNotFindStore<T> _value,
      $Res Function(SFCouldNotFindStore<T>) _then)
      : super(_value, (v) => _then(v as SFCouldNotFindStore<T>));

  @override
  SFCouldNotFindStore<T> get _value => super._value as SFCouldNotFindStore<T>;
}

/// @nodoc
class _$SFCouldNotFindStore<T> implements SFCouldNotFindStore<T> {
  const _$SFCouldNotFindStore();

  @override
  String toString() {
    return 'InfraFailure<$T>.couldNotFindStore()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFCouldNotFindStore<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return couldNotFindStore();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (couldNotFindStore != null) {
      return couldNotFindStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return couldNotFindStore(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (couldNotFindStore != null) {
      return couldNotFindStore(this);
    }
    return orElse();
  }
}

abstract class SFCouldNotFindStore<T> implements InfraFailure<T> {
  const factory SFCouldNotFindStore() = _$SFCouldNotFindStore<T>;
}

/// @nodoc
abstract class $SFImageUploadErrorCopyWith<T, $Res> {
  factory $SFImageUploadErrorCopyWith(SFImageUploadError<T> value,
          $Res Function(SFImageUploadError<T>) then) =
      _$SFImageUploadErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFImageUploadErrorCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFImageUploadErrorCopyWith<T, $Res> {
  _$SFImageUploadErrorCopyWithImpl(
      SFImageUploadError<T> _value, $Res Function(SFImageUploadError<T>) _then)
      : super(_value, (v) => _then(v as SFImageUploadError<T>));

  @override
  SFImageUploadError<T> get _value => super._value as SFImageUploadError<T>;
}

/// @nodoc
class _$SFImageUploadError<T> implements SFImageUploadError<T> {
  const _$SFImageUploadError();

  @override
  String toString() {
    return 'InfraFailure<$T>.imageUploadError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFImageUploadError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return imageUploadError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (imageUploadError != null) {
      return imageUploadError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return imageUploadError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (imageUploadError != null) {
      return imageUploadError(this);
    }
    return orElse();
  }
}

abstract class SFImageUploadError<T> implements InfraFailure<T> {
  const factory SFImageUploadError() = _$SFImageUploadError<T>;
}

/// @nodoc
abstract class $SFUnIdentifiedLocationCopyWith<T, $Res> {
  factory $SFUnIdentifiedLocationCopyWith(SFUnIdentifiedLocation<T> value,
          $Res Function(SFUnIdentifiedLocation<T>) then) =
      _$SFUnIdentifiedLocationCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFUnIdentifiedLocationCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFUnIdentifiedLocationCopyWith<T, $Res> {
  _$SFUnIdentifiedLocationCopyWithImpl(SFUnIdentifiedLocation<T> _value,
      $Res Function(SFUnIdentifiedLocation<T>) _then)
      : super(_value, (v) => _then(v as SFUnIdentifiedLocation<T>));

  @override
  SFUnIdentifiedLocation<T> get _value =>
      super._value as SFUnIdentifiedLocation<T>;
}

/// @nodoc
class _$SFUnIdentifiedLocation<T> implements SFUnIdentifiedLocation<T> {
  const _$SFUnIdentifiedLocation();

  @override
  String toString() {
    return 'InfraFailure<$T>.unIdentifiedLocation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFUnIdentifiedLocation<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return unIdentifiedLocation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unIdentifiedLocation != null) {
      return unIdentifiedLocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return unIdentifiedLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unIdentifiedLocation != null) {
      return unIdentifiedLocation(this);
    }
    return orElse();
  }
}

abstract class SFUnIdentifiedLocation<T> implements InfraFailure<T> {
  const factory SFUnIdentifiedLocation() = _$SFUnIdentifiedLocation<T>;
}

/// @nodoc
abstract class $SFPaymentFailureCopyWith<T, $Res> {
  factory $SFPaymentFailureCopyWith(
          SFPaymentFailure<T> value, $Res Function(SFPaymentFailure<T>) then) =
      _$SFPaymentFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$SFPaymentFailureCopyWithImpl<T, $Res>
    extends _$InfraFailureCopyWithImpl<T, $Res>
    implements $SFPaymentFailureCopyWith<T, $Res> {
  _$SFPaymentFailureCopyWithImpl(
      SFPaymentFailure<T> _value, $Res Function(SFPaymentFailure<T>) _then)
      : super(_value, (v) => _then(v as SFPaymentFailure<T>));

  @override
  SFPaymentFailure<T> get _value => super._value as SFPaymentFailure<T>;
}

/// @nodoc
class _$SFPaymentFailure<T> implements SFPaymentFailure<T> {
  const _$SFPaymentFailure();

  @override
  String toString() {
    return 'InfraFailure<$T>.paymentFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SFPaymentFailure<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult insufficientPermissions(),
    @required TResult serverError(),
    @required TResult invalidData(),
    @required TResult invalidPin(),
    @required TResult notFound(),
    @required TResult couldNotFindStore(),
    @required TResult imageUploadError(),
    @required TResult unIdentifiedLocation(),
    @required TResult paymentFailure(),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return paymentFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult insufficientPermissions(),
    TResult serverError(),
    TResult invalidData(),
    TResult invalidPin(),
    TResult notFound(),
    TResult couldNotFindStore(),
    TResult imageUploadError(),
    TResult unIdentifiedLocation(),
    TResult paymentFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (paymentFailure != null) {
      return paymentFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(SFUnexpected<T> value),
    @required
        TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    @required TResult serverError(SFServerError<T> value),
    @required TResult invalidData(SFInValidData<T> value),
    @required TResult invalidPin(SFInvalidPin<T> value),
    @required TResult notFound(SFCustomerNotFound<T> value),
    @required TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    @required TResult imageUploadError(SFImageUploadError<T> value),
    @required TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    @required TResult paymentFailure(SFPaymentFailure<T> value),
  }) {
    assert(unexpected != null);
    assert(insufficientPermissions != null);
    assert(serverError != null);
    assert(invalidData != null);
    assert(invalidPin != null);
    assert(notFound != null);
    assert(couldNotFindStore != null);
    assert(imageUploadError != null);
    assert(unIdentifiedLocation != null);
    assert(paymentFailure != null);
    return paymentFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(SFUnexpected<T> value),
    TResult insufficientPermissions(SFInsufficientPermissions<T> value),
    TResult serverError(SFServerError<T> value),
    TResult invalidData(SFInValidData<T> value),
    TResult invalidPin(SFInvalidPin<T> value),
    TResult notFound(SFCustomerNotFound<T> value),
    TResult couldNotFindStore(SFCouldNotFindStore<T> value),
    TResult imageUploadError(SFImageUploadError<T> value),
    TResult unIdentifiedLocation(SFUnIdentifiedLocation<T> value),
    TResult paymentFailure(SFPaymentFailure<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (paymentFailure != null) {
      return paymentFailure(this);
    }
    return orElse();
  }
}

abstract class SFPaymentFailure<T> implements InfraFailure<T> {
  const factory SFPaymentFailure() = _$SFPaymentFailure<T>;
}
